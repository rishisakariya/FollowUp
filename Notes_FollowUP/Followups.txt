php artisan serve --host=0.0.0.0 --port=8000

user controller

post adduser(),alluser(),oneuserby id(login)
put updateuser()

all are done user 
problem token in userbyid it show anyof and show only login user then Me API it declare in down 


followups controller

post addfollowup()
put updatefollowupstatus()
get followup by userid , followup by receiver id ,
delete followup by id 



receiver controller

post addreceiver()
put updatereceiver()
get one receiverby User id(receiver),allreceivers()
delete receiver by  id 









Register flow
When a user registers using the /api/SignUp API:

Laravel creates the user account.

Then, it sends a verification email with a link (the "Verify Email" button).

The link looks like this: /api/email/verify/{id}/{hash} ‚Äî this is used to verify the user.

‚ùó What the Frontend Needs to Do:
Laravel doesn‚Äôt know which user clicked the email link unless it also receives the user‚Äôs token.

So the frontend has to handle it like this:

‚úÖ 1. After Registering
Show this message to the user:

üü¢ ‚ÄúA verification email has been sent. Please check your inbox and click the 'Verify Email' button.‚Äù

‚úÖ 2. When the User Clicks the Button in Email
The email link will open something like this:

bash
Copy
Edit
http://your-frontend.com/verify-email/{id}/{hash}
Your frontend app should:

Extract the id and hash from the URL.

Get the token from localStorage (this token was received after signup).

Send this API request to Laravel:

javascript
Copy
Edit
// Example using Axios
const token = localStorage.getItem('token');

await axios.get(`/api/email/verify/${id}/${hash}`, {
  headers: {
    Authorization: `Bearer ${token}`
  }
});
‚úÖ This tells Laravel: "This user has clicked the verify email link."

‚úÖ 3. (Optional) Check If Email Is Verified
You can call this API to check if a user's email is verified:

javascript
Copy
Edit
await axios.get('/api/email/is-verified', {
  headers: {
    Authorization: `Bearer ${token}`
  }
});
It will return:

json
Copy
Edit
{
  "verified": true
}
üîí Protected Routes = Only For Verified Users
You‚Äôve already added the verified middleware in Laravel. This means:

Unverified users will NOT be able to access protected APIs like /profile, /addfollowups, etc.

They must verify their email first.

üîÅ Full Simple Flow (Frontend + Backend):
‚úÖ Call POST /api/SignUp

‚úÖ Backend sends email with verification link

‚úÖ User clicks the link in their email

‚úÖ Frontend reads id and hash from the URL

‚úÖ Frontend calls GET /api/email/verify/{id}/{hash} with the stored token

‚úÖ Laravel marks the email as verified







How it works
Login flow:

User enters email & password in React Native app.

App sends POST request to /api/login on Laravel.

Laravel checks credentials and returns a token.

React Native saves the token locally (Secure Storage or AsyncStorage).

For every future API request, React Native sends:

makefile

Authorization: Bearer <token>















Perfect Forgot & Reset Password Workflow (Laravel + React Native)
1. User Initiates "Forgot Password"

User opens the Forgot Password screen in the React Native app.

User enters their registered email address and submits.

2. React Native Sends Forgot Password Request

The app sends a POST request to Laravel backend API /forgot-password with the user‚Äôs email.

Backend validates the email exists.

Backend generates a unique, secure token for password reset.

Backend stores the token (hashed) with expiry in database (default 60 minutes).

Backend sends an email to the user containing a password reset link with the token and email as URL parameters.

3. User Receives Reset Email

User checks their email inbox.

User clicks the password reset link.

The link contains a token and the email as query parameters.

This opens either:

A web page (if web app)

Or is intercepted by React Native app through deep linking or universal linking.

4. React Native Opens Reset Password Screen

The app captures the token and email from the link.

It navigates user to a Reset Password screen.

The screen has fields:

New Password

Confirm Password

5. User Enters New Password & Submits

User inputs new password and confirmation.

User submits the form.

React Native app sends a POST request to backend /reset-password API with:

Email

Token

New Password

Password Confirmation

6. Laravel Validates & Processes Reset

Backend verifies:

Token exists and is valid (matches email, not expired).

Password and confirmation match and meet security rules.

If valid:

Backend hashes new password.

Updates the user‚Äôs password in the database.

Deletes/invalidates the token to prevent reuse.

Returns a success response.

7. React Native Receives Response

If success:

Shows a success message ("Password reset successful").

Optionally navigates user to login screen.

If failure (invalid token, expired token, validation errors):

Shows appropriate error messages.

Optionally suggests requesting a new reset link.

8. Security Considerations Throughout

Tokens expire after a short period (e.g., 60 minutes).

Tokens are single-use.

Passwords are validated with strong rules.

Passwords stored hashed using secure algorithms.

API responses avoid leaking whether an email exists.



Summary Flowchart (Conceptual)

User requests reset ‚Üí

Backend generates token + emails link ‚Üí

User clicks link ‚Üí React Native app captures token/email ‚Üí

User submits new password ‚Üí Backend validates + updates password ‚Üí

Backend responds ‚Üí React Native shows success or error


















üîê FORGOT & RESET PASSWORD WORKFLOW
üì± Frontend (React Native) + üñ•Ô∏è Backend (Laravel API)
üîÅ Step 1: User Requests Password Reset
üßë‚Äçüíª Frontend:

Shows "Forgot Password" screen with an email input.

User enters their email and taps ‚ÄúSend Reset Link‚Äù.

Sends a POST request to backend API.

üß∞ Backend:

Validates the email.

If valid, generates a secure token.

Stores token in the password resets table.

Sends an email to the user with a special reset link containing:

The token

The user‚Äôs email

This link points to a backend route that redirects to your frontend app.

üì© Step 2: User Clicks Email Link
üìß Email:

The reset link looks like:

https://your-backend.com/reset-password-form/{token}?email=user@example.com

üñ•Ô∏è Backend:

The route that handles this URL:

Reads the token and email.

Redirects the user to your frontend app‚Äôs reset password screen.

Example redirect URL:

https://your-frontend.com/reset-password?token=xxx&email=user@example.com

üß≠ Step 3: Frontend Shows Reset Password Screen
üì± Frontend:

Receives the token and email via the URL.

Displays a form with:

New password

Confirm password

On submit, sends a POST request to the backend with:

email

token

new password

confirm password

üîê Step 4: Backend Resets the Password
üß∞ Backend:

Validates the request:

Checks token, email, password rules.

If valid:

Updates the password in the users table.

Deletes the used token.

Responds with a success message.

‚úÖ Step 5: Frontend Shows Success Message
üì± Frontend:

Shows confirmation to user: ‚ÄúPassword changed successfully.‚Äù

Optionally navigates user to login screen.

üì¶ Summary of Responsibilities:
| Task                     | Frontend (React Native) | Backend (Laravel)          |
| ------------------------ | ----------------------- | -------------------------- |
| Forgot password screen   | ‚úÖ                       | ‚ùå                          |
| Send request with email  | ‚úÖ                       | ‚úÖ Validate, generate token |
| Send reset email         | ‚ùå                       | ‚úÖ With redirect link       |
| Handle email link        | ‚ùå                       | ‚úÖ Redirect to frontend     |
| Show reset password form | ‚úÖ                       | ‚ùå                          |
| Submit new password      | ‚úÖ                       | ‚úÖ Validate and reset       |
| Confirm success          | ‚úÖ                       | ‚úÖ Respond success          |















migration specific table after changes in the migration table file 
php artisan migrate:refresh --path=database\migrations\2025_08_07_101004_create_receiver_table.php

this refresh method is used for firstly table rollback after migrate




can i define it in the post method

ChatGPT said:
Yes, you can absolutely define a route and handle fetching a user by user_id using a POST request instead of GET ‚Äî though traditionally, GET is preferred for retrieving resources.

However, if you're using POST (e.g., to pass the user_id in the body instead of the URL), here‚Äôs how you can do it.

‚úÖ Step-by-Step: Fetch User by user_id via POST
‚úÖ 1. Define Route in routes/api.php
php
Copy
Edit
use App\Http\Controllers\UserController;

Route::post('/user/fetch', [UserController::class, 'fetchUserById']);
‚úÖ 2. Controller Method (UserController.php)
php
Copy
Edit
namespace App\Http\Controllers;

use App\Models\User;
use Illuminate\Http\Request;

class UserController extends Controller
{
    public function fetchUserById(Request $request)
    {
        // Validate the input
        $request->validate([
            'user_id' => 'required|integer|exists:users,user_id',
        ], [
            'user_id.required' => 'User ID is required.',
            'user_id.integer'  => 'User ID must be an integer.',
            'user_id.exists'   => 'No user found with this ID.',
        ]);

        // Fetch the user
        $user = User::find($request->user_id);

        return response()->json([
            'success' => true,
            'user' => $user,
        ]);
    }
}
‚úÖ 3. Example Request
POST /api/user/fetch
Body (JSON):

json
Copy
Edit
{
  "user_id": 1
}
Success Response:

json
Copy
Edit
{
  "success": true,
  "user": {
    "user_id": 1,
    "name": "Jane Doe",
    "email": "jane@example.com"
  }
}
Validation Error (if user doesn't exist):

json
Copy
Edit
{
  "message": "The given data was invalid.",
  "errors": {
    "user_id": [
      "No user found with this ID."
    ]
  }
}




















Great ‚Äî you're working with app/Http/Kernel.php, which is where Laravel defines which middleware run for different route groups like web and api.

You're asking:

Where and what should I change in this file to ensure token-based (Sanctum) authentication works for API routes?

Let‚Äôs go step-by-step.

‚úÖ Goal
You want to make sure Sanctum token authentication works for your API routes using the auth:sanctum middleware.

üîß What to do in Kernel.php
üîπ1. Enable Sanctum middleware in the api group
Currently, yours looks like this (commented out):

php
Copy
Edit
'api' => [
    // \Laravel\Sanctum\Http\Middleware\EnsureFrontendRequestsAreStateful::class,
    \Illuminate\Routing\Middleware\ThrottleRequests::class.':api',
    \Illuminate\Routing\Middleware\SubstituteBindings::class,
],
‚úÖ Change it to this:
php
Copy
Edit
'api' => [
    \Laravel\Sanctum\Http\Middleware\EnsureFrontendRequestsAreStateful::class, // üëà uncomment this
    \Illuminate\Routing\Middleware\ThrottleRequests::class.':api',
    \Illuminate\Routing\Middleware\SubstituteBindings::class,
],
üß† Note: The EnsureFrontendRequestsAreStateful middleware is only needed if you're using Sanctum with session/cookie-based auth, like for SPA apps.
For token-based APIs (mobile/postman), it‚Äôs technically optional, but keeping it doesn't hurt and allows flexibility.

üîπ2. No other changes required in Kernel.php
The auth middleware (auth:sanctum) is already available via this alias:

php
Copy
Edit
'auth' => \App\Http\Middleware\Authenticate::class,
‚úÖ What to do in routes/api.php
Protect your routes using auth:sanctum like this:

php
Copy
Edit
use App\Http\Controllers\UserController;

Route::middleware('auth:sanctum')->group(function () {
    Route::get('/profile', [UserController::class, 'profile']);
    Route::put('/user/{id}', [UserController::class, 'updateUser']);
});
These routes will now require a valid token in the request Authorization: Bearer <token> header.

‚úÖ Optional: Customize token error message
If you want to change the default:

json
Copy
Edit
{
  "message": "Unauthenticated."
}
to something like:

json
Copy
Edit
{
  "success": false,
  "message": "Token not provided. User not logged in."
}
Go to: app/Exceptions/Handler.php
And override the unauthenticated() method:

php
Copy
Edit
use Illuminate\Auth\AuthenticationException;

protected function unauthenticated($request, AuthenticationException $exception)
{
    return response()->json([
        'success' => false,
        'message' => 'Authorization token missing or invalid. Please log in.',
    ], 401);
}
‚úÖ Summary
Step	What to Do
1Ô∏è‚É£	Uncomment Sanctum middleware in 'api' group in Kernel.php
2Ô∏è‚É£	Use auth:sanctum in your protected routes
3Ô∏è‚É£	(Optional) Customize unauthenticated() in Handler.php













but how to automatically logout in 15 days means login time to 15 days after that destroy token automatically

ChatGPT said:
Great ‚Äî you're asking how to make Laravel Sanctum tokens expire automatically after 15 days, so that a user is logged out automatically after that time.

By default, Sanctum tokens do not expire unless you revoke or delete them manually.

‚úÖ Goal
You want:

"After a user logs in, the token should automatically expire after 15 days."

üîß How to implement token expiry in Laravel Sanctum
Laravel Sanctum doesn't support token expiration out-of-the-box, so you'll need to manually handle it by:

‚úÖ Step 1: Store the token's created time
This is already done for you.

Each token is stored in the personal_access_tokens table and has a created_at timestamp.

‚úÖ Step 2: Manually check token age in a custom middleware
You need to:

Create a middleware to check if the token is older than 15 days.

Apply it to routes where you want token expiry to be enforced.

‚úÖ Step 3: Create middleware to check expiry
Run this command:

bash
Copy
Edit
php artisan make:middleware TokenExpiryMiddleware
Then open:
üìÑ app/Http/Middleware/TokenExpiryMiddleware.php

And add:

php
Copy
Edit
namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Carbon;

class TokenExpiryMiddleware
{
    public function handle(Request $request, Closure $next)
    {
        $token = $request->user()?->currentAccessToken();

        if (!$token) {
            return response()->json([
                'success' => false,
                'message' => 'Unauthorized. Token not found.',
            ], 401);
        }

        // Check if token is older than 15 days
        $createdAt = $token->created_at;
        $expiresAt = $createdAt->copy()->addDays(15);

        if (now()->greaterThan($expiresAt)) {
            // Optionally delete the expired token
            $token->delete();

            return response()->json([
                'success' => false,
                'message' => 'Token expired. Please log in again.',
            ], 401);
        }

        return $next($request);
    }
}
‚úÖ Step 4: Register the middleware
Open:
üìÑ app/Http/Kernel.php

In the protected $middlewareAliases array, add:

php
Copy
Edit
'token.expiry' => \App\Http\Middleware\TokenExpiryMiddleware::class,
‚úÖ Step 5: Apply middleware to protected routes
In routes/api.php, use both auth:sanctum and your new middleware:

php
Copy
Edit
Route::middleware(['auth:sanctum', 'token.expiry'])->group(function () {
    Route::get('/profile', [UserController::class, 'profile']);
    // other protected routes
});
‚úÖ How it works
On each request, it checks if the token is older than 15 days.

If yes ‚Üí deletes the token and returns an error response.

If no ‚Üí allows access.

üß™ Example Expiry Test
If user logs in on 2025-08-01, and makes a request on 2025-08-17, they will see:

json
Copy
Edit
{
  "success": false,
  "message": "Token expired. Please log in again."
}
‚úÖ Bonus (Optional)
You can also set expiration dynamically or include an expires_at field in the personal_access_tokens table if you want finer control.

Let me know if you want that version too.






üîí Better Option (No user_id in URL)
If each user should only access their own profile, you can avoid the user_id in the URL entirely.

‚úÖ Route:
php
Copy
Edit
Route::get('/me', [UserController::class, 'me']);
‚úÖ Controller:
php
Copy
Edit
public function me(Request $request)
{
    return response()->json([
        'success' => true,
        'user' => $request->user(),
    ]);
}
This way:

No risk of accessing another user's data

Less to validate

More secure by default












111 

1|8DIOIDQPpuaQ2ML4XBMhVR4PqrBf8NAnUm4HAG753d7f5359
4|HUKhOaWSi82bw4kNzUE4pmfnb4H8H1UrCLxofvGF8a0fca22


222

5|uAw5OIOFVqdXpnrG73ZMaQ6FrY4fVzq8Q9mYLnOJe5a19747
6|bRGMX6X5tuMUSHK74AipTVIfQv6ExtiF88hbQc8I7befa1aa


6|tkiSdSv3Txmqd5aIvXfozu4zaj02DfBexYkLpjS5ed4de8fa



followup by user id

if login token is user's 1 the show only users'1 followup 

public function getMyFollowUps()
{
    $user = auth()->user();

    if (!$user) {
        return response()->json([
            'success' => false,
            'message' => 'Unauthenticated.',
        ], 401);
    }

    // Get follow-ups only for the authenticated user
    $followups = Followup::where('creator', $user->user_id)->get();

    return response()->json([
        'success' => true,
        'message' => 'Follow-ups retrieved successfully.',
        'data' => $followups,
    ]);
}

Route::middleware('auth:sanctum')->get('/followups/my', [FollowupController::class, 'getMyFollowUps']);


















email verifications


Great ‚Äî once you‚Äôve set up email verification in Laravel using API, here‚Äôs how it works with a React Native frontend. This guide shows the end-to-end flow, including how React Native should interact with your Laravel backend.

‚úÖ High-Level Workflow
User registers (sign up)

Laravel sends email verification link

User clicks the link (from email) ‚Üí triggers Laravel verification route

Frontend checks verification status

Access to protected routes only after verification

üîÅ Step-by-Step Flow (React Native + Laravel)
üßæ 1. Register User via API
‚úÖ React Native
Use fetch or Axios:

js
Copy
Edit
await axios.post('https://yourdomain.com/api/SignUp', {
  name: 'John Doe',
  email: 'john@example.com',
  password: 'password123'
});
‚úÖ Laravel Response
Laravel automatically sends verification email.

The verification URL will look like:

ruby
Copy
Edit
https://yourdomain.com/api/email/verify/3/f6d0c73... (signed URL)
üì© 2. Laravel Sends Verification Email
Laravel sends email to user's inbox with a signed verification link.

You can customize the template using app/Notifications/VerifyEmail.php if needed.

‚úÖ 3. User Clicks Email Link
When the user clicks the link, it hits this API:

bash
Copy
Edit
GET /api/email/verify/{id}/{hash}
Laravel handles this and marks email as verified.

Important: Laravel expects the user to be authenticated, so you'll need to:

Login first in React Native

Store token (from Laravel Sanctum)

Pass token in Authorization header when user clicks the verification link in browser.

üîí 4. Restrict Backend Routes to Verified Users
Example in api.php:

php
Copy
Edit
Route::middleware(['auth:sanctum', 'verified'])->group(function () {
    Route::get('/profile', [UserController::class, 'profile']);
});
Now only verified users can access /profile.

üëÄ 5. React Native: Check If User is Verified
Endpoint:
http
Copy
Edit
GET /api/email/is-verified
Headers: Authorization: Bearer {token}
Response:
json
Copy
Edit
{ "verified": true }
React Native logic:

js
Copy
Edit
const res = await axios.get('https://yourdomain.com/api/email/is-verified', {
  headers: { Authorization: `Bearer ${token}` }
});

if (res.data.verified) {
  // Allow access to app
} else {
  // Show "please verify your email"
}
üîÅ 6. Resend Verification Email (optional)
React Native can trigger:

http
Copy
Edit
POST /api/email/verify/send
Headers: Authorization: Bearer {token}
Use when user says ‚ÄúI didn‚Äôt receive the email‚Äù.

üîê Authentication Notes
Use Sanctum for token-based auth in mobile apps.

You must add Accept: application/json to all requests.

Save the token in AsyncStorage or SecureStore in React Native.

üö¶ Final Checklist
Step	Laravel API	React Native
Register user	POST /api/SignUp	Axios/fetch form
Receive verification email	Automatic via Laravel	User clicks link in email
Verify email	GET /api/email/verify/{id}/{hash}	Opens in browser (auto verified)
Check verification status	GET /api/email/is-verified	Use token to check status
Resend email (optional)	POST /api/email/verify/send	‚ÄúResend verification‚Äù button
 







































ChatGPT said:
Great ‚Äî since you've already implemented registration, and now you're adding email verification via API in Laravel 10, here's a full list of required file changes (and additions) to enable email verification.

‚úÖ Required File Changes for Email Verification
1. User Model
You already did this ‚úÖ
Ensure:

php
Copy
Edit
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Contracts\Auth\MustVerifyEmail;

class User extends Authenticatable implements MustVerifyEmail
2. Migration: Add email_verified_at
You already did this ‚úÖ

php
Copy
Edit
$table->timestamp('email_verified_at')->nullable();
3. Add Email Verification Routes
üìç File: routes/api.php

php
Copy
Edit
use Illuminate\Foundation\Auth\EmailVerificationRequest;

// Send verification email
Route::post('/email/verify/send', function (Request $request) {
    if ($request->user()->hasVerifiedEmail()) {
        return response()->json(['message' => 'Email already verified.'], 200);
    }

    $request->user()->sendEmailVerificationNotification();
    return response()->json(['message' => 'Verification link sent!'], 200);
})->middleware(['auth:sanctum'])->name('verification.send');

// Handle verification link
Route::get('/email/verify/{id}/{hash}', function (EmailVerificationRequest $request) {
    $request->fulfill();
    return response()->json(['message' => 'Email verified successfully.'], 200);
})->middleware(['auth:sanctum', 'signed'])->name('verification.verify');

// Check verification status
Route::get('/email/is-verified', function (Request $request) {
    return response()->json(['verified' => $request->user()->hasVerifiedEmail()]);
})->middleware(['auth:sanctum']);
4. Controller: Send Verification Link (Optional)
If you want a dedicated method (instead of route closure):

üìç File: UserController.php

php
Copy
Edit
use Illuminate\Http\Request;

public function sendVerificationEmail(Request $request)
{
    if ($request->user()->hasVerifiedEmail()) {
        return response()->json(['message' => 'Email already verified.'], 200);
    }

    $request->user()->sendEmailVerificationNotification();
    return response()->json(['message' => 'Verification link sent!'], 200);
}
Then map it in api.php:

php
Copy
Edit
Route::post('/email/verify/send', [UserController::class, 'sendVerificationEmail'])
    ->middleware('auth:sanctum');
5. Protect Routes with verified Middleware
If you want to restrict access to only verified users:

php
Copy
Edit
Route::middleware(['auth:sanctum', 'verified'])->group(function () {
    Route::get('/profile', [UserController::class, 'profile']);
    // other protected routes...
});
6. Mail Configuration
üìç File: .env

Use log for local dev:

env
Copy
Edit
MAIL_MAILER=log
Or use SMTP if you want to send actual emails:

env
Copy
Edit
MAIL_MAILER=smtp
MAIL_HOST=smtp.mailtrap.io
MAIL_PORT=2525
MAIL_USERNAME=your_mailtrap_username
MAIL_PASSWORD=your_mailtrap_password
MAIL_ENCRYPTION=null
MAIL_FROM_ADDRESS=no-reply@example.com
MAIL_FROM_NAME="Your App Name"
‚úÖ Optional (but useful)
7. Frontend Verification Support
If you're building a frontend (e.g., Vue, React, Postman), you need to:

Extract the verification URL from email

Visit it with the token (signed route)

Then verify the user using the /email/verify/{id}/{hash} endpoint

Would you like me to generate a fully working minimal version of the updated UserController.php or Postman collection too?




































üîß Step-by-Step: Customize Laravel Email Verification
‚úÖ 1. Create a Custom Notification

Run in terminal:

php artisan make:notification CustomVerifyEmail


This creates:

üìÑ app/Notifications/CustomVerifyEmail.php

‚úÖ 2. Edit CustomVerifyEmail.php

Replace the file content with this:

<?php

namespace App\Notifications;

use Illuminate\Auth\Notifications\VerifyEmail as VerifyEmailBase;
use Illuminate\Support\Carbon;
use Illuminate\Support\Facades\URL;
use Illuminate\Notifications\Messages\MailMessage;

class CustomVerifyEmail extends VerifyEmailBase
{
    public function toMail($notifiable)
    {
        $verificationUrl = $this->verificationUrl($notifiable);

        return (new MailMessage)
            ->subject('üìß Verify Your Email Address')
            ->greeting('Hello!')
            ->line('Please click the button below to verify your email address.')
            ->action('Verify Email Address', $verificationUrl)
            ->line('If you did not create an account, no further action is required.')
            ->salutation('Regards, Laravel Team');
    }

    protected function verificationUrl($notifiable)
    {
        return URL::temporarySignedRoute(
            'verification.verify', // make sure your route is named this
            Carbon::now()->addMinutes(60),
            [
                'id' => $notifiable->getKey(),
                'hash' => sha1($notifiable->getEmailForVerification()),
            ]
        );
    }
}

‚úÖ 3. Modify User.php Model to Use the Custom Notification

Open: app/Models/User.php

Add the following at the bottom of the class:

use App\Notifications\CustomVerifyEmail;

public function sendEmailVerificationNotification()
{
    $this->notify(new CustomVerifyEmail);
}


üìù This overrides Laravel‚Äôs default and sends your custom version instead.

‚úÖ 4. Ensure Your Route Is Named Correctly

In your routes/api.php file, make sure your verification route looks like this:

use Illuminate\Auth\Events\Verified;
use Illuminate\Http\Request;
use App\Models\User;

Route::get('/email/verify/{id}/{hash}', function (Request $request, $id, $hash) {
    $user = User::findOrFail($id);

    if (! hash_equals(sha1($user->email), $hash)) {
        return response()->json(['message' => 'Invalid verification link.'], 403);
    }

    if ($user->hasVerifiedEmail()) {
        return response()->json(['message' => 'Email already verified.']);
    }

    $user->markEmailAsVerified();
    event(new Verified($user));

    return response()->json(['message' => 'Email verified successfully.']);
})->middleware(['signed'])->name('verification.verify');


‚úÖ Notice the ->name('verification.verify') ‚Äî that‚Äôs required for the link to generate correctly.

‚úÖ 5. Trigger Email Sending

Whenever a user signs up or logs in and needs email verification, Laravel will now send your custom email with the correct signed link.

üîç Result

‚úÖ Subject: üìß Verify Your Email Address

‚úÖ Signed link:

http://127.0.0.1:8000/api/email/verify/16/{hash}?expires=...&signature=...


‚úÖ Custom wording and button text





















üß† Summary: Full Workflow Diagram For ForgetPassword
[Client sends POST /api/forgot-password with email]
                ‚Üì
      [Laravel validates email]
                ‚Üì
[Laravel generates token + stores in password_resets table]
                ‚Üì
      [Laravel sends email with reset link]
                ‚Üì
     [User clicks link ‚Üí opens frontend reset page]
                ‚Üì
[Client sends POST /api/reset-password with token + new password]
                ‚Üì
    [Laravel verifies token ‚Üí updates password ‚Üí done!]
